<tool id="pathview_node.info" name="node.info" version="@VERSION@.0">
    <description>extracts node information</description>
     <macros>
       <import>pathview_macros.xml</import>
    </macros>

    <requirements>
        <requirement type="package" version="@VERSION@">bioconductor-pathview</requirement>
    </requirements>

    <command detect_errors="exit_code"><![CDATA[
        Rscript '$script'
    ]]></command>

    <configfiles>
        <configfile name="script"><![CDATA[
## Setup R error handling to go to stderr
options(show.error.messages=F, error=function(){cat(geterrmessage(),file=stderr());q("no",1,F)})
loc <- Sys.setlocale("LC_MESSAGES", "en_US.UTF-8")

## Import library
library(pathview)

object <- "$object"

#if str($short_name) != ""
    short_name <- TRUE
#else
    short_name <- FALSE
#end if

data <- node.info(object, short.name = short_name)

#if str($output) == "kegg.names"
    write.table(unlist(data[1]), "$kegg_names_output", row.name=FALSE, col.name=FALSE, quote=FALSE)
#end if
#if str($output) == "type"
    write.table(unlist(data[2]), "$type_output", row.name=FALSE, col.name=FALSE, quote=FALSE)
#end if
#if str($output) == "component"
    write.table(unlist(data[3]), "$component_output", row.name=FALSE, col.name=FALSE, quote=FALSE)
#end if
#if str($output) == "size"
    write.table(unlist(data[4]), "$size_output", row.name=FALSE, col.name=FALSE, quote=FALSE)
#end if
#if str($output) == "labels"
    write.table(unlist(data[5]), "$labels_output", row.name=FALSE, col.name=FALSE, quote=FALSE)
#end if
#if str($output) == "shape"
    write.table(unlist(data[6]), "$shape_output", row.name=FALSE, col.name=FALSE, quote=FALSE)
#end if
#if str($output) == "x"
    write.table(unlist(data[7]), "$x_output", row.name=FALSE, col.name=FALSE, quote=FALSE)
#end if
#if str($output) == "y"
    write.table(unlist(data[8]), "$y_output", row.name=FALSE, col.name=FALSE, quote=FALSE)
#end if
#if str($output) == "width"
    write.table(unlist(data[9]), "$width_output", row.name=FALSE, col.name=FALSE, quote=FALSE)
#end if
#if str($output) == "height"
    write.table(unlist(data[10]), "$height_output", row.name=FALSE, col.name=FALSE, quote=FALSE)
#end if

#if str($node_map_select.node_map_selector) == "yes"
    #if str($node_map_select.mol_data_select.mol_data_selector) == "yes"
        mol_data <- scan("$node_map_select.mol_data_select.mol_data", what=character())
    #else
        mol_data <- NULL
    #end if
    node_types <- "$node_map_select.node_types"
    node_sum <- "$node_map_select.node_sum"
    #if str($node_map_select.entrez_gnodes) != ""
        entrez_gnodes <- TRUE
    #else
        entrez_gnodes <- FALSE
    #end if

    result <- node.map(mol.data = mol_data, data, node.types = node_types, node.sum = node_sum, entrez.gnodes=entrez_gnodes)

    write.table(result, "$node_map_output", row.name=FALSE, col.name=TRUE, quote=FALSE)

    #if str($node_map_select.node_color_select.node_color_selector) == "yes"
        #if str($node_map_select.node_color_select.discrete) != ""
            discrete <- TRUE
        #else 
            discrete <- FALSE
        #end if

        #if str($node_map_select.node_color_select.data_select) == "gene"
            limit <- as.numeric("$node_map_select.node_color_select.data_select.gene_limit")
        #else
            limit <- as.numeric("$node_map_select.node_color_select.data_select.cpd_limit")
        #end if
        bins <- as.numeric("$node_map_select.node_color_select.bin")

        #if str($node_map_select.node_color_select.both_dirs) != ""
            both_dirs <- TRUE
        #end if
        low <- "$node_map_select.node_color_select.low"
        mid <- "$node_map_select.node_color_select.mid"
        high <- "$node_map_select.node_color_select.high"
        na_col <- "$node_map_select.node_color_select.na_col"

        #if str($node_map_select.node_color_select.trans_fun) != "none"
            trans_fun <- "$node_map_select.node_color_select.trans_fun"
        #else
            trans_fun <- NULL
        #end if

        node_color <- node.color(plot.data = result, discrete=discrete, limit=limit, bins=bins, both.dirs = both_dirs, low = low, mid = mid, high = high, na.col = na_col, trans.fun = trans_fun)

        write.table(node_color, "$node_color_output", row.name=FALSE, col.name=FALSE, quote=FALSE)
    #end if
#end if
]]>
        </configfile>
    </configfiles>
    <inputs>
        <param name="object" type="data" format="xml" label="KGML file" />
        <param name="short_name" type="boolean" truevalue="true" falsevalue="" checked="true" label="Short labels" help="i.e. the first iterm separated by a comma in the long labels are parsed out as node labels" />
        <param name="output" type="select" label="Which extracted node information to output?" >
            <option value="kegg.names">kegg.names</option>
            <option value="type">type</option>
            <option value="component">component</option>
            <option value="size">size</option>
            <option value="labels">labels</option>
            <option value="shape">shape</option>
            <option value="x">x</option>
            <option value="y">y</option>
            <option value="width">width</option>
            <option value="height">height</option>
        </param>
        <conditional name="node_map_select">
            <param name="node_map_selector" type="select" label="Map molecular data onto KEGG pathway nodes?">
                <option value="yes">Yes</option>
                <option value="no" selected="true">No</option>
            </param>
            <when value="yes">
                <conditional name="mol_data_select">
                    <param name="mol_data_selector" type="select" label="Specify mol data?">
                        <option value="yes">Yes</option>
                        <option value="no" selected="true">No</option>
                    </param>
                    <when value="yes">
                        <param name="mol_data" type="data" format="tabular" label="mol data" help="Either a dataframe with one numeric column labeled with molecule IDs as names (single sample) or a matrix-like data (multiple sample)." />
                    </when>
                    <when value="no"> </when>
                </conditional>
                <param name="node_types" type="select" label="Specify the node type to map to the mol data" >
                    <option value="gene">Gene</option>
                    <option value="compound">Compound</option>
                    <option value="ortholog">Ortholog</option>
                </param>
                <param name="node_sum" type="select" label="Specify the method name to calculate node summary given that multiple genes or compounds are mapped to it" >
                    <option value="sum">sum</option>
                    <option value="mean">mean</option>
                    <option value="max">max</option>
                    <option value="max_abs">max.abs</option>
                    <option value="random">random</option>
                </param>
                <param name="entrez_gnodes" type="boolean" truevalue="true" falsevalue="" checked="true" label="Use EntrezGene (NCBI GeneID) as the default gene ID in the KEGG data files?" help="This is needed because KEGG uses different types default gene ID for different species. Some most common model species use EntrezGene, but majority of others use Locus tag." />
                <conditional name="node_color_select">
                    <param name="node_color_selector" type="select" label="Code molecular data as pseudo colors on the pathway graph?">
                        <option value="yes">Yes</option>
                        <option value="no" selected="true">No</option>
                    </param>
                    <when value="yes">
                        <param name="discrete" type="boolean" truevalue="true" falsevalue="" checked="false" label="Treat the molecular data or node summary data as discrete?" help="If no is selected, mol.data will be a charactor vector of molecular IDs"/>
                        <conditional name="data_select">
                            <param name="data_selector" type="select" label="Is the mapped molecular data gene.data or cpd.data?">
                                <option value="gene">gene</option>
                                <option value="cpd">cpd</option>
                            </param>
                            <when value="gene">
                                <param name="gene_limit" type="float" value="0.5" label="Specify the limit value for gene.data when converting them to pseudo colors" help="Specify length 1 or 2. Length 1 suggests discrete data or 1 directional (positive-valued) data, or the absolute limit for 2 directional data. Length 2 suggests 2 directional data." />
                            </when>
                            <when value="cpd">
                                <param name="cpd_limit" type="float" value="1" label="Specify the limit value for cpd.data when converting them to pseudo colors" help="Specify length 1 or 2. Length 1 suggests discrete data or 1 directional (positive-valued) data, or the absolute limit for 2 directional data. Length 2 suggests 2 directional data."/>
                            </when>
                        </conditional>
                        <param name="bin" type="integer" value="10" label="Specify the number of levels or bins for gene.data or cpd.data when converting them to pseudo colors" />
                        <param name="both_dirs" type="boolean" truevalue="true" falsevalue="" checked="true" label="gene.data or cpd.data is a 1 directional data when converting them to pseudo colors?" />
                        <param name="low" type="text" value="green" label="Specify the low color spectra to code gene.data or cpd.data" help="When data are 1 directional (TRUE value in both.dirs), only mid and high are used to specify the color spectra. The color values can be given as color names (red), plot color index (2=red), and HTML-style RGB, (#FF0000)." />
                        <param name="mid" type="text" value="gray" label="Specify the mid color spectra to code gene.data or cpd.data" help="When data are 1 directional (TRUE value in both.dirs), only mid and high are used to specify the color spectra. The color values can be given as color names (red), plot color index (2=red), and HTML-style RGB, (#FF0000)." />
                        <param name="high" type="text" value="red" label="Specify the high color spectra to code gene.data or cpd.data" help="When data are 1 directional (TRUE value in both.dirs), only mid and high are used to specify the color spectra. The color values can be given as color names (red), plot color index (2=red), and HTML-style RGB, (#FF0000)." />
                        <param name="na_col" type="text" value="transparent" label="Color used for NA's or missing values in gene.data or cpd.data" />
                        <param name="trans_fun" type="select" label="How should gene.data and cpd.data be transformed?">
                            <option value="none">no transformation</option>
                            <option value="log">log transformation</option>
                            <option value="abs">abs transformation</option>
                        </param>
                    </when>
                    <when value="no"> </when>
                </conditional>
            </when>
            <when value="no"> </when>
        </conditional>
    </inputs>

    <outputs>
        <data name="kegg_names_output" format="txt" label="node.info on ${on_string}: kegg.names output" >
            <filter>output == "kegg.names"</filter>
        </data>
        <data name="type_output" format="txt" label="node.info on ${on_string}: type output" >
            <filter>output == "type"</filter>
        </data>
        <data name="component_output" format="txt" label="node.info on ${on_string}: component output" >
            <filter>output == "component"</filter>
        </data>
        <data name="size_output" format="txt" label="node.info on ${on_string}: size output" >
            <filter>output == "size"</filter>
        </data>
        <data name="labels_output" format="txt" label="node.info on ${on_string}: labels output" >
            <filter>output == "labels"</filter>
        </data>
        <data name="shape_output" format="txt" label="node.info on ${on_string}: shape output" >
            <filter>output == "shape"</filter>
        </data>
        <data name="x_output" format="txt" label="node.info on ${on_string}: x output" >
            <filter>output == "x"</filter>
        </data>
        <data name="y_output" format="txt" label="node.info on ${on_string}: y output" >
            <filter>output == "y"</filter>
        </data>
        <data name="width_output" format="txt" label="node.info on ${on_string}: width output" >
            <filter>output == "width"</filter>
        </data>
        <data name="height_output" format="txt" label="node.info on ${on_string}: height output" >
            <filter>output == "height"</filter>
        </data>
        <data name="node_map_output" format="txt" label="node.map on ${on_string}: output" >
            <filter>node_map_select['node_map_selector']=="yes"</filter>
        </data>
        <data name="node_color_output" format="txt" label="node.color on ${on_string}: output" >
            <filter>node_map_select['node_map_selector']=="yes" and node_map_select['node_color_select']['node_color_selector'] == "yes"</filter>
        </data>
    </outputs>

    <tests>
        <test expect_num_outputs="1">
            <param name="object" value="hsa04110.xml" />
            <param name="short_name" value="true" />
            <param name="output" value="kegg.names" />
             <conditional name="node_map_select">
                <param name="node_map_selector" value="no" />
            </conditional>
            <output name="kegg_names_output" value="kegg.names_output.txt" />
        </test>
        <test expect_num_outputs="2">
            <param name="object" value="hsa04110.xml" />
            <param name="short_name" value="true" />
            <param name="output" value="kegg.names" />
             <conditional name="node_map_select">
                <param name="node_map_selector" value="yes" />
                <conditional name="mol_data_select">
                    <param name="mol_data_selector" value="no" />
                </conditional>
                <param name="node_types" value="gene" />
                <param name="node_sum" value="sum" />
                <param name="entrez_gnodes" value="true" />
            </conditional>
            <output name="kegg_names_output" value="kegg.names_output.txt" />
            <output name="node_map_output" value="node_map_output1.txt" />
        </test>
        <test expect_num_outputs="2">
            <param name="object" value="hsa04110.xml" />
            <param name="short_name" value="true" />
            <param name="output" value="kegg.names" />
             <conditional name="node_map_select">
                <param name="node_map_selector" value="yes" />
                <conditional name="mol_data_select">
                    <param name="mol_data_selector" value="yes" />
                    <param name="mol_data" value="mol_data.tabular" />
                </conditional>
                <param name="node_types" value="gene" />
                <param name="node_sum" value="sum" />
                <param name="entrez_gnodes" value="true" />
            </conditional>
             <conditional name="node_color_select">
                <param name="node_color_selector" value="no" />
            </conditional>
            <output name="kegg_names_output" value="kegg.names_output.txt" />
            <output name="node_map_output" value="node_map_output2.txt" />
        </test>
        <test expect_num_outputs="3">
            <param name="object" value="hsa04110.xml" />
            <param name="short_name" value="true" />
            <param name="output" value="kegg.names" />
             <conditional name="node_map_select">
                <param name="node_map_selector" value="yes" />
                <conditional name="mol_data_select">
                    <param name="mol_data_selector" value="yes" />
                    <param name="mol_data" value="mol_data.tabular" />
                </conditional>
                <param name="node_types" value="gene" />
                <param name="node_sum" value="sum" />
                <param name="entrez_gnodes" value="true" />
            </conditional>
             <conditional name="node_color_select">
                <param name="node_color_selector" value="yes" />
                <param name="discrete" value="false" />
                <conditional name="data_select">
                    <param name="data_selector" value="cpd" />
                    <param name="cpd_limit" value="1" />
                </conditional>
                <param name="bin" value="10" />
                <param name="both_dirs" value="true" />
                <param name="low" value="green" />
                <param name="mid" value="gray" />
                <param name="high" value="red" />
                <param name="na_col" value="transparent" />
                <param name="trans_fun" value="none"/>
            </conditional>
            <output name="kegg_names_output" value="kegg.names_output.txt" />
            <output name="node_map_output" value="node_map_output2.txt" />
            <output name="node_color_output" value="node_color_output.txt" />
        </test>
    </tests>

    <help><![CDATA[
Extract node information from KEGG pathway. The parser function, parser KGML file and/or extract node information from KEGG pathway.

Parser function node.info extract node data from parsed KEGG pathways. KGML files are parsed using parseKGML2 and KEGGpathway2Graph2. These functions from KEGGgraph package have been heavily modified for reaction parsing and conversion to edges.

It returns:

- a named list of 10 elements: "kegg.names", "type", "component", "size", "labels", "shape", "x", "y", "width" and "height". Each elements record the corresponding attribute for all nodes in the parsed KEGG pathway.

===========================================================================================================================================

If map molecular data onto KEGG pathway nodes is selected. The mapper function, mapping molecular data(gene expression, metabolite abundance etc)to nodes in KEGG pathway.

Mapper function node.map maps user supplied molecular data to KEGG pathways. This function takes standard KEGG molecular IDs (Entrez Gene ID or KEGG Compound Accession) and map them to pathway nodes. None KEGG molecular gene IDs or Compound IDs are pre-mapped to standard KEGG IDs by calling another function mol.sum. When multiple molecules map to one node, the corresponding molecular data are summarized into a single node summary by calling function specified by node.sum. This mapped node summary data together with the parsed KGML data are then returned for further processing. Proper input data include: gene expression, protein expression, genetic association, metabolite abundance, genomic data, literature, and other data types mappable to pathways. The input mol.data may be NULL, then no molecular data are actually mapped, but all nodes of the specified node.type are considered "mappable" and their parsed KGML data returned.

It returns:

A dataframe of parsed KGML data and summary molecular data for each mapped node with the columns:

- `kegg.names:` standard KEGG IDs/Names for mapped nodes. It’s Entrez Gene ID or KEGG Compound Accessions.
- `labels:` Node labels to be used when needed
- `type:` node type, currently 4 types are supported: "gene","enzyme", "compound" and "ortholog".
- `x:` x coordinate in the original KEGG pathway graph.
- `y:` y coordinate in the original KEGG pathway graph.
- `width:` node width in the original KEGG pathway graph.
- `height:` node height in the original KEGG pathway graph.
- `other:` columns columns of the mapped gene/compound data

===========================================================================================================================================

If code molecular data as pseudo colors on the pathway graph is selected, the function node.color converts the mapped molecular data (gene.data or cpd.data) by node.map function into pseudo colors, which then can be plotted on the pathway graph. col.key is used in combination with node.color in pathview, although this function can be used independently for similar tasks.

It returns:

- dataframe with one column or a matrix of colors. Its dimensionality is the same as the corresponding gene.data or cpd.data. col.key plots a color key on existing pathway graph, then returns a updated version of off.sets for the reference of next color key.

    ]]></help>
    <expand macro="citations" />
</tool>